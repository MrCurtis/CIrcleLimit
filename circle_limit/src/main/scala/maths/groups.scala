package circle_limit.maths

import spire.implicits._

import Imaginary.i
import ComplexMatrix.ComplexMatrix

/**
 * Representation of a group generated by a set of Moebius transforms.
 */
class Group(generators: List[MoebiusTransformation], wordLength: Int) {

  /**
   * The set of all Moebius transformations which can be represented as a
   * word of length wordLength, with each element of the word representing
   * either a generator or an inverse of a generator.
   *
   * Note that if we have any word with consecutive elements mutual inverses
   * of each other then this word will be excluded from being calculated. For
   * example if we have two word abcd and ad, and it is the case that bc = Id
   * then only ad will be calculated and the corresponding Moebius
   * transformation added to the returned set.
   * However, if there exists more complicated identities then words including
   * them are not excluded from calculation. For example if we have a word
   * abcdef with bcd = Id then the Moebius transformations corresponding to
   * both aef and abcdef are calculated. Mathematically these should be the
   * same but rounding errors mean that they may be added to the returned set
   * as different transformations.
   */
  val elements = allWordsOfLength(wordLength)

  /**
   * Returns the images of the geodesic under the elements of the group
   * corresponding to words of length less than or equal to wordLength.
   */
  def getImagesOfGeodesic(geodesic: Geodesic): List[Geodesic] = {
    elements map (t => t transform geodesic )
  }

  /**
   * Returns the images of all the geodesics under all the elements of the group
   * corresponding to words of length less than or equal to wordLength.
   */
  def getImagesOfGeodesics(geodesics: List[Geodesic]): List[Geodesic] = {
      geodesics flatMap getImagesOfGeodesic
  }

  private def allWordsOfLength(wordLength: Int) = {
    def allWordsRecurse(
        left: ComplexMatrix,
        right: ComplexMatrix,
        iterationsLeft: Int)
        : List[ComplexMatrix] = {
      val composed = left * right
      val allApartFromInverse = generatorsAndInverses.filter( _ != inverseOf(right) )
      if (iterationsLeft > 0) {
        List(composed) ++ (
          allApartFromInverse flatMap (
            x => (allWordsRecurse(composed, x, iterationsLeft-1))
          )
        )
      } else {
        List(composed)
      }
    }
    val id = ComplexMatrix.identity
    allWordsRecurse(id, id, wordLength) map (m => MoebiusTransformation(m.a, m.b, m.c, m.d))
  }

  private def generatorsAsMatrices = 
    generators map (t => t.theTransformationMatrix)

  private def generatorsAsMatricesWithInverses =
    generatorsAsMatrices map (m => (m, m.inverse))

  private def generatorsAndInverses = 
    generatorsAsMatricesWithInverses flatMap (m => List(m._1, m._2))

  private def inverseOf(matrix: ComplexMatrix): ComplexMatrix = {
    def getInverse(listOfMatrices: List[(ComplexMatrix, ComplexMatrix)])
        : ComplexMatrix = {
      listOfMatrices match {
        case (`matrix`, x) :: xs => x
        case (x, `matrix`) :: xs => x
        case _ :: xs => getInverse(xs)
        case _ => ComplexMatrix.identity
      }
    }
    getInverse( generatorsAsMatricesWithInverses )
  }
  
}
object Group {
  def apply(generators: List[MoebiusTransformation], wordLength: Int) = 
    new Group(generators, wordLength)

  val trivialGroup = apply(
    List(MoebiusTransformation.identity),
    0
  )

  def torsionFreeGroup(iterationDepth: Int) = apply(
    List(
      MoebiusTransformation(3.0, 2.0+1.0*i, 2.0-1.0*i, 3.0),
      MoebiusTransformation(3.0, 2.0-1.0*i, 2.0+1.0*i, 3.0)
    ),
    iterationDepth
  )
}
