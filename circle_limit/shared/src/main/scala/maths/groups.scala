package circle_limit.maths

/**
 * Representation of a group generated by a set of Moebius transforms.
 */
class Group(generators: List[MoebiusTransformation], wordLength: Int) {

  /**
   * The set of all Moebius transformations which can be represented as a
   * word of length wordLength, with each element of the word representing
   * either a generator or an inverse of a generator.
   *
   * Note that if we have any word with consecutive elements mutual inverses
   * of each other then this word will be excluded from being calculated. For
   * example if we have two word abcd and ad, and it is the case that bc = Id
   * then only ad will be calculated and the corresponding Moebius
   * transformation added to the returned set.
   * However, if there exists more complicated identities then words including
   * them are not excluded from calculation. For example if we have a word
   * abcdef with bcd = Id then the Moebius transformations corresponding to
   * both aef and abcdef are calculated. Mathematically these should be the
   * same but rounding errors mean that they may be added to the returned set
   * as different transformations.
   */
  val elements = allWordsOfLength(wordLength)

  private def allWordsOfLength(wordLength: Int) = {
    def allWordsRecurse(
        left: MoebiusTransformationMatrix,
        right: MoebiusTransformationMatrix,
        iterationsLeft: Int)
        : Set[MoebiusTransformationMatrix] = {
      val composed = left * right
      val allApartFromInverse = generatorsAndInverses.toSet - inverseOf(right)
      if (iterationsLeft > 0) {
        Set(composed) union (
          allApartFromInverse flatMap (
            x => (allWordsRecurse(composed, x, iterationsLeft-1))
          )
        )
      } else {
        Set(composed)
      }
    }
    println("This bit get calledd")
    val id = MoebiusTransformationMatrix.identity
    allWordsRecurse(id, id, wordLength) map (m => MoebiusTransformation(m.a, m.b, m.c, m.d))
  }

  private def generatorsAsMatrices = 
    generators map (t => t.theTransformationMatrix)

  private def generatorsAsMatricesWithInverses =
    generatorsAsMatrices map (m => (m, m.inverse))

  private def generatorsAndInverses = 
    generatorsAsMatricesWithInverses flatMap (m => List(m._1, m._2))

  private def inverseOf(matrix: MoebiusTransformationMatrix): MoebiusTransformationMatrix = {
    def getInverse(listOfMatrices: List[(MoebiusTransformationMatrix, MoebiusTransformationMatrix)])
        : MoebiusTransformationMatrix = {
      listOfMatrices match {
        case (`matrix`, x) :: xs => x
        case (x, `matrix`) :: xs => x
        case _ :: xs => getInverse(xs)
        case _ => MoebiusTransformationMatrix.identity
      }
    }
    getInverse( generatorsAsMatricesWithInverses )
  }
  
}
object Group {
  def apply(generators: List[MoebiusTransformation], wordLength: Int) = 
    new Group(generators, wordLength)
}
